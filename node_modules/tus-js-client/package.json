{
  "_args": [
    [
      {
        "raw": "tus-js-client@^1.4.5",
        "scope": null,
        "escapedName": "tus-js-client",
        "name": "tus-js-client",
        "rawSpec": "^1.4.5",
        "spec": ">=1.4.5 <2.0.0",
        "type": "range"
      },
      "C:\\wamp64\\www\\digital\\node_modules\\uppy"
    ]
  ],
  "_from": "tus-js-client@>=1.4.5 <2.0.0",
  "_id": "tus-js-client@1.4.5",
  "_inCache": true,
  "_location": "/tus-js-client",
  "_nodeVersion": "5.12.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/tus-js-client-1.4.5.tgz_1508777200709_0.896181070478633"
  },
  "_npmUser": {
    "name": "acconut",
    "email": "marius@accoplex.com"
  },
  "_npmVersion": "3.8.6",
  "_phantomChildren": {},
  "_requested": {
    "raw": "tus-js-client@^1.4.5",
    "scope": null,
    "escapedName": "tus-js-client",
    "name": "tus-js-client",
    "rawSpec": "^1.4.5",
    "spec": ">=1.4.5 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/uppy"
  ],
  "_resolved": "https://registry.npmjs.org/tus-js-client/-/tus-js-client-1.4.5.tgz",
  "_shasum": "ee525df8a2c4dc4113bcf933ddd7d40a3db43b95",
  "_shrinkwrap": null,
  "_spec": "tus-js-client@^1.4.5",
  "_where": "C:\\wamp64\\www\\digital\\node_modules\\uppy",
  "babel": {
    "presets": [
      "es2015"
    ]
  },
  "browser": {
    "./lib/node/request.js": "./lib/browser/request.js",
    "./lib/node/base64.js": "./lib/browser/base64.js",
    "./lib/node/storage.js": "./lib/browser/storage.js",
    "./lib/node/source.js": "./lib/browser/source.js",
    "./lib.es5/node/request.js": "./lib.es5/browser/request.js",
    "./lib.es5/node/base64.js": "./lib.es5/browser/base64.js",
    "./lib.es5/node/storage.js": "./lib.es5/browser/storage.js",
    "./lib.es5/node/source.js": "./lib.es5/browser/source.js"
  },
  "bugs": {
    "url": "https://github.com/tus/tus-js-client/issues"
  },
  "dependencies": {
    "buffer-from": "^0.1.1",
    "extend": "^3.0.0",
    "lodash.throttle": "^4.1.1",
    "resolve-url": "^0.2.1"
  },
  "description": "A pure JavaScript client for the tus resumable upload protocol",
  "devDependencies": {
    "babel-cli": "^6.6.5",
    "babel-eslint": "^4.1.8",
    "babel-preset-es2015": "^6.1.18",
    "babelify": "^7.3.0",
    "browserify": "^12.0.0",
    "colors": "^1.1.2",
    "derequire": "^2.0.3",
    "eslint": "^1.6.0",
    "exorcist": "^0.4.0",
    "get-saucelabs-browsers": "^1.0.1",
    "jasmine": "^2.5.2",
    "jasmine-ajax": "^3.2.0",
    "jasmine-core": "^2.4.1",
    "phantomjs-prebuilt": "^2.1.15",
    "replace": "^0.3.0",
    "temp": "^0.8.3",
    "uglify-js": "^2.6.0",
    "watchify": "^3.5.0"
  },
  "directories": {},
  "dist": {
    "shasum": "ee525df8a2c4dc4113bcf933ddd7d40a3db43b95",
    "tarball": "https://registry.npmjs.org/tus-js-client/-/tus-js-client-1.4.5.tgz"
  },
  "gitHead": "7c792b4ee9613f6a1537da5538c5a6670bfeac33",
  "homepage": "https://github.com/tus/tus-js-client",
  "jsnext:main": "lib/index.js",
  "keywords": [
    "tus",
    "resumable",
    "upload",
    "protocol",
    "progress",
    "file",
    "browser"
  ],
  "license": "MIT",
  "main": "lib.es5/index.js",
  "maintainers": [
    {
      "name": "acconut",
      "email": "marius@accoplex.com"
    }
  ],
  "name": "tus-js-client",
  "optionalDependencies": {},
  "readme": "# tus-js-client [![Build Status](https://travis-ci.org/tus/tus-js-client.svg?branch=master)](https://travis-ci.org/tus/tus-js-client)\nA pure JavaScript client for the [tus resumable upload protocol](http://tus.io)\nwhich works in browser environments and Node.js.\n\n## Example\n\n```js\ninput.addEventListener(\"change\", function(e) {\n    // Get the selected file from the input element\n    var file = e.target.files[0]\n\n    // Create a new tus upload\n    var upload = new tus.Upload(file, {\n        endpoint: \"http://localhost:1080/files/\",\n        retryDelays: [0, 1000, 3000, 5000],\n        onError: function(error) {\n            console.log(\"Failed because: \" + error)\n        },\n        onProgress: function(bytesUploaded, bytesTotal) {\n            var percentage = (bytesUploaded / bytesTotal * 100).toFixed(2)\n            console.log(bytesUploaded, bytesTotal, percentage + \"%\")\n        },\n        onSuccess: function() {\n            console.log(\"Download %s from %s\", upload.file.name, upload.url)\n        }\n    })\n\n    // Start the upload\n    upload.start()\n})\n```\n\n## Installation\n\nThe sources are compiled into a [UMD](https://github.com/umdjs/umd)\n(`dist/tus.js`) which can be loaded using different approaches:\n\n* **Embed using a script tag:** `<script src=\"dist/tus.js\"></script>` and access\nthe tus methods using the `tus` property in `window`\n* **Install from NPM:** `npm install tus-js-client`:\n`var tus = require(\"tus-js-client\")`\n* **Define using AMD:** `define(\"alpha\", [\"dist/tus.js\"], function(tus) {})`\n\n\n## Basic Usage\n\n1. **Create** a new `tus.Upload` instance by passing the file to be uploaded alongside additional options to its constructor.\n2. **Start** the upload using the `Upload#start` function. This will create the upload resource if necessary and then transfer the file to the remote endpoint.\n3. Optionally **pause** the upload if the user/application wishes to do so using `Upload#abort`. This will cause any currently running transfers to be immediately stopped.\n4. Optionally **resume** the previously paused upload by called `Upload#start` again. This will resume the upload at the point at which it had stopped before. You can also use this approach to continue the upload after an error has occurred.\n\nPlease consult the documentation below for more details.\n\n## Browser support\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/marius_transloadit.svg)](https://saucelabs.com/u/marius_transloadit)\n\nWe use localStorage, XMLHttpRequest2, the File API and Blob API. About 85% of\ntoday's users should be able to use this software, calculated using\n[iwanttouse.com](http://www.iwanttouse.com/#namevalue-storage,xhr2,fileapi,blobbuilder).\n\n## Node compatibility\n\nSince Node's environment is quite different than a browser's runtime and\nprovides other capabilities but also restrictions, tus-js-client will have a\nslightly changed behavior when used in the context of a Node.js application:\n\n* As the Web Storage API is only available in browser environments,\ntus-js-client will not be able store the URLs of created uploads allowing\nautomatic resuming. Please consult the documentation for the `tus.canStoreURLs`\nfor more information on this specific topic.\n\n* The `tus.Upload` constructor will only accept instances of `buffer.Buffer`\nand `stream.Readable` as file inputs. If you are passing a readable stream as\nthis argument, you must set the `chunkSize` option to a finite integer value\nbecause the chunk, which is currently being uploaded, will be held in memory\nallowing automatic retries, e.g. after connection interruptions. Therefore\nadditional care should be taken when choosing the appropriate value for your\nspecific application to control memory consumption.\n\n* If you call the `tus.Upload` constructor with an instance of the\n`fs.ReadStream`, the above point does not apply, meaning *no* chunk will be held\nin memory. Instead, tus-js-client will create it's own stream starting at the\nneeded position using `fs.createReadStream`. If you want to disable this\nfunctionality, you may want to wrap the `fs.ReadStream` into a\n`stream.PassThrough`.\n\nFinally, you may be interested in the `demo/node.js` example which demonstrates\na simple example on how to easily use tus-js-client using Node.js.\n\n## Internals\n\nOnce a new file should be uploaded the client will create a new upload resource\non the server using a `POST` request. A successful response will contain a\n`Location` header pointing to the upload URL. This URL will be used to transfer\nthe file to the server using one or multiple `PATCH` requests.\nIn addition tus-js-client will generate a unique fingerprint for every file and\nstore it and the upload URL using the Web Storage API. If the upload is\ninterrupted or aborted manually, the client is able to resume the upload by\nretrieving the upload URL using the fingerprint. The client is even able to\nresume after you close your browser or shut down your device. Now the client can\ncontinue to send `PATCH` requests to the server until the upload is finished.\n\n## Extension support\n\nThe tus specification defines multiple [extensions](http://tus.io/protocols/resumable-upload.html#protocol-extensions) which can be optionally\nimplemented beside the core protocol enabling specific functionality. Not all\nof these extensions are interesting or even useful for a client-side library\nand therefore support for all of them in tus-js-client is not guaranteed.\n\n* The **Creation** extension is mostly implemented and is used for creating the\nupload. Deferring the upload's length is not possible at the moment.\n\n* The Checksum extension requires that the checksum is calculated inside the\nbrowser. While this is totally doable today, it's particularly expensive and\ntime intensive for bigger files and on mobile devices. One solution is to\nutilize the new Web Crypto API, which probably offers better performance and\nsecurity, but you could argue whether it has reached critical mass yet.\n\n* The Concatenation extension is mostly meant for parallel uploads where you\nneed to utilize multiple HTTP connections. In most cases, this does not apply\nto the environment of the browser but it can also be used for different things.\n\nAt the moment, coverage for these extensions is not great but we promise to\nimprove this situation in the near future.\n\n## Documentation\n\n### tus.isSupported\n\nA boolean indicating whether the current browser has the features necessary to\nuse tus-js-client. This can be used to test support and warn the user.\n\n### tus.canStoreURLs\n\nA boolean indicating whether the current environment allows storing URLs\nenabling the corresponding upload to be resumed if the same file (identified\nusing fingerprinting) is passed to the constructor again. Since this storage\nmechanism is currently bound to the Web Storage API, this value will only yield\nto `true` if we are in a browser environment which provides access to the\n`localStorage` object. Please be aware that in some cases, e.g. a sandboxed\niframe, the Web Storage API is provided but cannot be used without causing\nsecurity errors. In these special situations or if no Web Storage API is\navailable, `canStoreURLs` is set to `false`.\n\n### tus.defaultOptions\n\nA object containing the default options used when creating a new upload:\n\n* `endpoint = \"\"`: a URL which will be used to create new uploads\n* `fingerprint`: a function used to generate a unique string from a\ncorresponding File object. This used to store the URL for an upload to resume.\nThis option is only used if the `resume` flag is set to true.\n* `resume = true`: a boolean indicating whether the client should attempt to\nresume the upload if the upload has been started in the past. This includes\nstoring the file's fingerprint. Use `false` to force an entire reupload.\n* `onProgress = null`: a function that will be called each time progress\ninformation is available. The arguments will be `bytesSent` and `bytesTotal`.\n* `onChunkComplete = null`: a function that will be called each time a chunk\nhas been successfully uploaded. The arguments will be `chunkSize`,\n`bytesAccepted`, `bytesTotal`.\n* `onSuccess = null`: a function called when the upload finished successfully.\n* `onError = null`: a function called once an error appears. The arguments will\nbe an Error instance.\n* `headers = {}`: an object with custom header values used in all requests.\n* `withCredentials = false`: a boolean which is be used as the value for\n`withCredentials` in all XMLHttpRequests to use Cookies in requests. The\nremote server must accept CORS and credentials.\n* `chunkSize = Infinity`: a number indicating the maximum size of a chunk\nuploaded in a single request\n* `metadata = {}`: an object with string values used as additional meta data\nwhich will be passed along to the server when (and only when) creating a new\nupload. Can be used for filenames, file types etc.\n* `uploadUrl = null`: a URL which will be used to directly attempt a resume\nwithout generating the fingerprint and looking it up before. If this attempt\nfails it will fall back to creating a new upload using the URL specified in\n`endpoint`. This will also force an attempt even if resuming has been disabled\nby setting `resume` to `false`.\n* `uploadSize = null`: an integer representing the size of the file in bytes.\nThis will only be used if the size cannot be automatically calculated. This\nis currently only used and required if you supply a `Readable` stream as the\nfile to upload. You may also use this to limit the position until which a file\nwill be uploaded.\n* `overridePatchMethod = false`: a boolean indicating whether the `POST` method\nshould be used instead of `PATCH` for transfering the chunks. This may be\nnecessary if a browser or the server does not support latter one. In this case,\na `POST` request will be made with the `X-HTTP-Method-Override: PATCH` header.\nThe server must be able to detect it, and then handle the request as if `PATCH`\nwould have been the method.\n* `retryDelays = null`: an array or null, indicating how many milliseconds should\npass before the next attempt to uploading will be started after the transfer has\nbeen interrupted. The array's length indicates the maximum number of attempts.\nFor more details about the system of retries and delays, read the\n[Automated Retries](#automated-retries) section.\n\n### new tus.Upload(file, options)\n\nCreate a new tus.Upload object. The upload will not be started automatically,\nuse `start` to do so.\n\nThe `file` argument must be an instance of `File` or `Blob` if you are in a\nbrowser environment. If it is executed using Node.js, the allowed types are\n`Buffer` and a `Readable` stream.\nThe `options` argument will be merged deeply with `tus.defaultOptions`.\n\n### tus.Upload#options\n\nThe `options` argument used in the constructor merged deeply with\n`tus.defaultOptions`.\n\n### tus.Upload#file\n\nThe `file` argument used in the constructor.\n\n### tus.Upload#url\n\nThe URL used to upload the file. Leave it set to `null` and the client will\ncreate a new upload and set this property to the new upload URL.\nYou may supply your own URL using this property and the client will try to\nresume using this URL.\n\n### tus.Upload#start()\n\nStart or resume the upload using the specified file. If no `file` property is\navailable the error handler will be called. If you supplied your own URL using\nthe `url` property the client will try to resume using this URL.\nIf not, the client will look up if the file has been (fully or partially)\nuploaded and tries to resume.\nIf no upload can be resume it will create a new upload using the supplied\n`endpoint` option.\n\n### tus.Upload#abort()\n\nAbort the currently running upload request and don't continue. You can resume\nthe upload by calling the `start` method again.\n\n### Difference between onProgress and onChunkComplete\n\nWhen configuring a new uploader, the `onProgress` and `onChunkComplete`\ncallbacks are available. While they may seem to be equal based on their\nnaming and the arguments, they provide different information in reality.\nProgress events are emitted using the `onProgress` option and provide numbers\nabout how much data has been sent to the server. However, this data may not\nhave been received or accepted by the endpoint. Imagine a network outage where\nthe browser reports to have successfully sent 100 bytes, but none of them ever\nreach the backend. In order to provide reliable information about whether the\nchunks have been accepted by the server, `onChunkComplete` is only invoked if\nwe have evidence that the remote endpoint has received and accepted the\nuploaded bytes. When consuming this functionality, the `chunkSize` option is\nfrom high importance since the callback will and invoked if an entire chunk\nhas been uploaded.\n\n### Automated Retries\n\nDue to tus' support for resumability, tus-js-client has been engineered to work even under bad networking conditions and provides options for controlling how it should act in different circumstances.\nOne of these settings is `retryDelays` which defines whether and how often tus-js-client will attempt a retry after the upload has been unintentionally interrupted. The value may either be `null`, to fully disable the described functionality, or an array of numbers. It's length will define how often retries will be attempted before giving up and the array's values indicate the delay between the upload interruption and the start of the next attempt in milliseconds. For example, a configuration of `[0, 1000, 3000, 5000]` will result in, at most, five attempts to resume the upload, including the initial one from calling `tus.Upload#start`. The first retry will occur instantly after the interruption, while the second attempt is going to be started after waiting for one second, the third after three seconds, and so on. If the fifth and final attempt also fails, the latest error will not be caught, but passed to the provided `onError` callback.\nThe underlying implementation is rather straightforward: Any error which would usually trigger the `onError` callback will be caught if following criteria are matched:\n- the error has been caused by networking issues, e.g. connection interruption or an unexpected/invalid response from the server, and\n- the environment does not explicitly report that the client is disconnected from any network, e.g. `navigator.onLine` in modern browsers, and\n- the maximum number of retries, defined by the array's length, has not been reached.\n\nIf all of these conditions are met, an attempt will be issued after applying the defined delay. Furthermore, once the client was able to successfully transfer chunks of the upload to the server, the counter for attempted retries will be reset to zero. For example, if an upload is interrupted the first delay will be applied. After reconnecting to the remote endpoint, it is able to transfer data to it until the connection is cut again. This time not the second delay will be used but the first one again because we were able to upload chunks. The reason for this behavior is that it will allow uploads to be interrupted more often than the `retryDelays` option defines, as long as we are making progress in uploading.\n\n## Building\n\n```bash\n# Install dependencies\nnpm install\n\n# Build dist/tus.js a single time\nnpm run build\n\n# Build all dist files (including minification)\nnpm run dist\n\n# Watch source and rebuild\nnpm run watch\n```\n\n## Testing\n\nTests are implemented using Jasmine and can be found in the `test/` directory.\nIn order to run the tests, open `test/SpecRunner.html` in a browser and you\nshould see a visual representation of the test results. No web server is\nrequired, you can open `SpecRunner.html` using the `file:///` protocol.\n\nTests can also be run on SauceLabs' cloud infrastructure using `npm test`.\nBefore using this command, you have to set up your SauceLabs account by filling\nthe `SAUCE_USERNAME` and `SAUCE_ACCESS_KEY` variables else the command will fail.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tus/tus-js-client.git"
  },
  "scripts": {
    "build": "browserify lib/index.js -t [ babelify ] -s tus -d | exorcist ./dist/tus.js.map | derequire > dist/tus.js",
    "dist": "npm run build && npm run minify",
    "lint": "eslint lib demo test bin",
    "minify": "uglifyjs ./dist/tus.js -o ./dist/tus.min.js --in-source-map ./dist/tus.js.map --source-map ./dist/tus.min.js.map --source-map-url tus.min.js.map",
    "node-test": "cd test; jasmine",
    "phantom-test": "phantomjs --ssl-protocol=any bin/phantom-jasmine.js",
    "sauce-test": "node bin/sauce-jasmine.js http://localhost:8081/test/SpecRunner.html",
    "test": "./bin/test",
    "transpile": "babel -d lib.es5/ lib/ && replace '^' '// Generated by Babel\n' ./lib.es5/*/*.js ./lib.es5/*.js --multiline=false",
    "watch": "watchify lib/index.js -t babelify -o dist/tus.js -s tus -v -d"
  },
  "version": "1.4.5"
}
